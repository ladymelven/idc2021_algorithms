<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Algorithms and data structures</title>
</head>
<body>
<!--<h4>Пузырьковая сортировка (результаты прогонов в консоли)</h4>-->
<!--<pre style="display: block">-->
<!--<code>-->
<!--  const bubbleSort = (arr) => {-->
<!--    let maxIndex = arr.length;-->
<!--    while (maxIndex > 0) {-->
<!--      for (let i = 1; i < maxIndex; i++) {-->
<!--        if (arr[i] < arr[i - 1]) {-->
<!--          const bigger = arr[i - 1];-->
<!--          arr[i - 1] = arr[i];-->
<!--          arr[i] = bigger;-->
<!--        }-->
<!--      }-->
<!--      maxIndex&#45;&#45;;-->
<!--    }-->
<!--    return arr;-->
<!--  }-->
<!--</code>-->
<!--</pre>-->


<!--<h4>Сортировка 2 (результаты прогонов в консоли)</h4>-->
<!--<pre>-->
<!--<code style="display: block">-->
<!--  const maxNumSort = (arr) => {-->
<!--    let maxIndex = arr.length;-->
<!--    while (maxIndex > 0) {-->
<!--      let maxNum = arr[0];-->
<!--      let maxNumIndex = 0;-->

<!--      for (let i = 1; i < maxIndex; i++) {-->
<!--        if (arr[i] > maxNum) {-->
<!--          maxNum = arr[i];-->
<!--          maxNumIndex = i;-->
<!--        }-->
<!--      }-->

<!--      arr[maxNumIndex] = arr[maxIndex - 1];-->
<!--      arr[maxIndex - 1] = maxNum;-->

<!--      maxIndex&#45;&#45;;-->
<!--    }-->
<!--    return arr;-->
<!--  }-->
<!--</code>-->
<!--</pre>-->


<!--<h4>Сортировка вставкой (результаты прогона в консоли)</h4>-->
<!--<pre>-->
<!--<code style="display: block">-->
<!--  const sortByInsert = (arr) => {-->
<!--    let sortedPartSize = 1;-->

<!--    while (sortedPartSize < arr.length) {-->
<!--      let currNumber = arr[sortedPartSize];-->

<!--      for (let i = sortedPartSize - 1; i > -1; i&#45;&#45;) {-->
<!--        if (arr[i] > currNumber) {-->
<!--          arr[i + 1] = arr[i];-->
<!--        } else {-->
<!--          arr[i + 1] = currNumber;-->
<!--          //mark current number as already inserted-->
<!--          currNumber = null;-->
<!--          break;-->
<!--        }-->
<!--      }-->
<!--      // if we haven't found a place for current number, it's the smallest, insert at 0-->
<!--      if (currNumber) {-->
<!--        arr[0] = currNumber;-->
<!--      }-->

<!--      sortedPartSize++;-->
<!--    }-->
<!--    return arr;-->
<!--  }-->
<!--</code>-->
<!--</pre>-->

<!--<h4>Обход дерева в глубину (результаты прогонов в консоли)</h4>-->
<!--<pre>-->
<!--<code style="display: block">-->
<!--const traverseTree = (tree) => {-->
<!--  const values = [];-->
<!--  let stack = [tree];-->

<!--  while(stack.length) {-->
<!--    const workingNode = stack[stack.length - 1];-->
<!--    values.push(workingNode.value);-->
<!--    stack.pop();-->

<!--    if (workingNode.next !== null && Array.isArray(workingNode.next)) {-->
<!--      for (let i = workingNode.next.length - 1; i > -1; i&#45;&#45;) {-->
<!--        stack.push(workingNode.next[i]);-->
<!--      }-->
<!--    }-->
<!--  }-->

<!--  return values;-->
<!--}-->
<!--</code>-->
<!--</pre>-->

<!--<h4>Обход дерева в ширину (результаты прогонов в консоли)</h4>-->
<!--<pre>-->
<!--<code style="display: block">-->
<!--const traverseTreeWidth = (tree) => {-->
<!--  const values = [];-->
<!--  let queue = [tree];-->

<!--  while(queue.length) {-->
<!--    const workingNode = queue.shift();-->
<!--    values.push(workingNode.value);-->

<!--    if (workingNode.next !== null && Array.isArray(workingNode.next)) {-->
<!--      for (const child of workingNode.next) {-->
<!--        queue.push(child);-->
<!--      }-->
<!--    }-->
<!--  }-->

<!--  return values;-->
<!--}-->
<!--</code>-->
<!--</pre>-->

<h4>Проверка скобок на валидность (результаты прогонов в консоли)</h4>
<pre>
<code style="display: block">
const checkParens = (expression) => {
  const parenArray = expression.split('');
  const stack = [];

  const openingParens = ['(', '{', '['];
  const round = ['(', ')'];
  const square = ['[', ']'];
  const curly = ['{', '}'];

  for (const paren of parenArray) {
    if (openingParens.includes(paren)) {
      stack.push(paren);
    } else {
      const lastParen = stack.pop();
      if (!(round.includes(paren) && round.includes(lastParen))
        && !(square.includes(paren) && square.includes(lastParen))
        && !(curly.includes(paren) && curly.includes(lastParen))) {
        return false;
      }
    }
  }

  return !stack.length;
}
</code>
</pre>

<script>
  const bubbleSort = (arr) => {
    let maxIndex = arr.length;
    while (maxIndex > 0) {
      for (let i = 1; i < maxIndex; i++) {
        if (arr[i] < arr[i - 1]) {
          const bigger = arr[i - 1];
          arr[i - 1] = arr[i];
          arr[i] = bigger;
        }
      }
      maxIndex--;
    }
    return arr;
  }

  const maxNumSort = (arr) => {
    let maxIndex = arr.length;
    while (maxIndex > 0) {
      let maxNum = arr[0];
      let maxNumIndex = 0;

      for (let i = 1; i < maxIndex; i++) {
        if (arr[i] > maxNum) {
          maxNum = arr[i];
          maxNumIndex = i;
        }
      }

      arr[maxNumIndex] = arr[maxIndex - 1];
      arr[maxIndex - 1] = maxNum;

      maxIndex--;
    }
    return arr;
  }

  const sortByInsert = (arr) => {
    let sortedPartSize = 1;

    while (sortedPartSize < arr.length) {
      let currNumber = arr[sortedPartSize];

      for (let i = sortedPartSize - 1; i > -1; i--) {
        if (arr[i] > currNumber) {
          arr[i + 1] = arr[i];
        } else {
          arr[i + 1] = currNumber;
          //mark current number as already inserted
          currNumber = null;
          break;
        }
      }
      // if we haven't found a place for current number, it's the smallest, insert at 0
      if (currNumber) {
        arr[0] = currNumber;
      }

      sortedPartSize++;
    }
    return arr;
  }

  const traverseTreeDepth = (tree) => {
    const values = [];
    let stack = [tree];

    while(stack.length) {
      const workingNode = stack.pop();
      values.push(workingNode.value);

      if (workingNode.next !== null && Array.isArray(workingNode.next)) {
        for (let i = workingNode.next.length - 1; i > -1; i--) {
          stack.push(workingNode.next[i]);
        }
      }
    }

    return values;
  }

  const traverseTreeWidth = (tree) => {
    const values = [];
    let queue = [tree];

    while(queue.length) {
      const workingNode = queue.shift();
      values.push(workingNode.value);

      if (workingNode.next !== null && Array.isArray(workingNode.next)) {
        for (const child of workingNode.next) {
          queue.push(child);
        }
      }
    }

    return values;
  }

  const checkParens = (expression) => {
    const parenArray = expression.split('');
    const stack = [];

    const openingParens = ['(', '{', '['];
    const round = ['(', ')'];
    const square = ['[', ']'];
    const curly = ['{', '}'];

    for (const paren of parenArray) {
      if (openingParens.includes(paren)) {
        stack.push(paren);
      } else {
        const lastParen = stack.pop();
        if (!(round.includes(paren) && round.includes(lastParen))
          && !(square.includes(paren) && square.includes(lastParen))
          && !(curly.includes(paren) && curly.includes(lastParen))) {
          return false;
        }
      }
    }

    return !stack.length;
  }

  console.log('()');
  console.log(checkParens('()'));
  console.log('[()]');
  console.log(checkParens('[()]'));
  console.log('[()]{}()[{({})}]');
  console.log(checkParens('[()]{}()[{({})}]'));
  console.log(')(){}[{}]');
  console.log(checkParens(')(){}[{}]'));
  console.log('()}');
  console.log(checkParens('()}'));
  console.log('(}{[]}');
  console.log(checkParens('(}{[]}'));
  console.log('()[{{()()[]}}]');
  console.log(checkParens('()[{{()()[]}}]'));
  console.log('()[{{()()[]}}]]');
  console.log(checkParens('()[{{()()[]}}]]'));
</script>
</body>
</html>
