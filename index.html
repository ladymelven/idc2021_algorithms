<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Algorithms and data structures</title>
</head>
<body>
<!--<h4>Пузырьковая сортировка (результаты прогонов в консоли)</h4>-->
<!--<pre style="display: block">-->
<!--<code>-->
<!--  const bubbleSort = (arr) => {-->
<!--    let maxIndex = arr.length;-->
<!--    while (maxIndex > 0) {-->
<!--      for (let i = 1; i < maxIndex; i++) {-->
<!--        if (arr[i] < arr[i - 1]) {-->
<!--          const bigger = arr[i - 1];-->
<!--          arr[i - 1] = arr[i];-->
<!--          arr[i] = bigger;-->
<!--        }-->
<!--      }-->
<!--      maxIndex&#45;&#45;;-->
<!--    }-->
<!--    return arr;-->
<!--  }-->
<!--</code>-->
<!--</pre>-->


<!--<h4>Сортировка 2 (результаты прогонов в консоли)</h4>-->
<!--<pre>-->
<!--<code style="display: block">-->
<!--  const maxNumSort = (arr) => {-->
<!--    let maxIndex = arr.length;-->
<!--    while (maxIndex > 0) {-->
<!--      let maxNum = arr[0];-->
<!--      let maxNumIndex = 0;-->

<!--      for (let i = 1; i < maxIndex; i++) {-->
<!--        if (arr[i] > maxNum) {-->
<!--          maxNum = arr[i];-->
<!--          maxNumIndex = i;-->
<!--        }-->
<!--      }-->

<!--      arr[maxNumIndex] = arr[maxIndex - 1];-->
<!--      arr[maxIndex - 1] = maxNum;-->

<!--      maxIndex&#45;&#45;;-->
<!--    }-->
<!--    return arr;-->
<!--  }-->
<!--</code>-->
<!--</pre>-->


<!--<h4>Сортировка вставкой (результаты прогона в консоли)</h4>-->
<!--<pre>-->
<!--<code style="display: block">-->
<!--  const sortByInsert = (arr) => {-->
<!--    let sortedPartSize = 1;-->

<!--    while (sortedPartSize < arr.length) {-->
<!--      let currNumber = arr[sortedPartSize];-->

<!--      for (let i = sortedPartSize - 1; i > -1; i&#45;&#45;) {-->
<!--        if (arr[i] > currNumber) {-->
<!--          arr[i + 1] = arr[i];-->
<!--        } else {-->
<!--          arr[i + 1] = currNumber;-->
<!--          //mark current number as already inserted-->
<!--          currNumber = null;-->
<!--          break;-->
<!--        }-->
<!--      }-->
<!--      // if we haven't found a place for current number, it's the smallest, insert at 0-->
<!--      if (currNumber) {-->
<!--        arr[0] = currNumber;-->
<!--      }-->

<!--      sortedPartSize++;-->
<!--    }-->
<!--    return arr;-->
<!--  }-->
<!--</code>-->
<!--</pre>-->

<!--<h4>Обход дерева в глубину (результаты прогонов в консоли)</h4>-->
<!--<pre>-->
<!--<code style="display: block">-->
<!--const traverseTree = (tree) => {-->
<!--  const values = [];-->
<!--  let stack = [tree];-->

<!--  while(stack.length) {-->
<!--    const workingNode = stack[stack.length - 1];-->
<!--    values.push(workingNode.value);-->
<!--    stack.pop();-->

<!--    if (workingNode.next !== null && Array.isArray(workingNode.next)) {-->
<!--      for (let i = workingNode.next.length - 1; i > -1; i&#45;&#45;) {-->
<!--        stack.push(workingNode.next[i]);-->
<!--      }-->
<!--    }-->
<!--  }-->

<!--  return values;-->
<!--}-->
<!--</code>-->
<!--</pre>-->

<!--<h4>Обход дерева в ширину (результаты прогонов в консоли)</h4>-->
<!--<pre>-->
<!--<code style="display: block">-->
<!--const traverseTreeWidth = (tree) => {-->
<!--  const values = [];-->
<!--  let queue = [tree];-->

<!--  while(queue.length) {-->
<!--    const workingNode = queue.shift();-->
<!--    values.push(workingNode.value);-->

<!--    if (workingNode.next !== null && Array.isArray(workingNode.next)) {-->
<!--      for (const child of workingNode.next) {-->
<!--        queue.push(child);-->
<!--      }-->
<!--    }-->
<!--  }-->

<!--  return values;-->
<!--}-->
<!--</code>-->
<!--</pre>-->

<!--<h4>Проверка скобок на валидность (результаты прогонов в консоли)</h4>-->
<!--<pre>-->
<!--<code style="display: block">-->
<!--  const checkParens = (expression) => {-->
<!--    const parenArray = expression.split('');-->
<!--    const stack = [];-->

<!--    const openingParens = ['(', '{', '['];-->
<!--    const round = ['(', ')'];-->
<!--    const square = ['[', ']'];-->
<!--    const curly = ['{', '}'];-->

<!--    for (const paren of parenArray) {-->
<!--      if (openingParens.includes(paren)) {-->
<!--        stack.push(paren);-->
<!--      } else {-->
<!--        const lastParen = stack.pop();-->
<!--        if (!(round.includes(paren) && round.includes(lastParen))-->
<!--          && !(square.includes(paren) && square.includes(lastParen))-->
<!--          && !(curly.includes(paren) && curly.includes(lastParen))) {-->
<!--          return false;-->
<!--        }-->
<!--      }-->
<!--    }-->

<!--    return !stack.length;-->
<!--  }-->
<!--</code>-->
<!--</pre>-->

<h4>Вывод всех простых чисел меньше N</h4>
<pre>
<code style="display: block">
  const primesUnderLimit = (limit) => {
    if (limit < 2) return null;

    const primes = [2];
    for (let i = 2; i <= limit; i++) {
      let isPrime = true;

      for (const prime of primes) {
        if (i % prime === 0) {
          isPrime = false;
          break;
        }
      }

      if (isPrime) {
        primes.push(i);
      }
    }

    return primes;
  }
</code>
</pre>

<h4>Бинарный поиск</h4>
<pre>
<code style="display: block">
  const binarySearch = (arr, number) => {
    if (!arr.length || number < arr[0] || number > arr[arr.length - 1]) {
      return null;
    }

    let left = 0;
    let right = arr.length - 1;

    while (left <= right) {
      const median = (left + right) / 2;

      if (arr[Math.ceil(median)] > number) {
        right = Math.floor(median);
      } else if (arr[Math.floor(median)] < number) {
        left = Math.ceil(median);
      } else if (arr[Math.ceil(median)] === number) {
        return Math.ceil(median);
      } else if (arr[Math.floor(median)] === number) {
        return Math.floor(median);
      }
    }
  }
</code>
</pre>

<script>
  const bubbleSort = (arr) => {
    let maxIndex = arr.length;
    while (maxIndex > 0) {
      for (let i = 1; i < maxIndex; i++) {
        if (arr[i] < arr[i - 1]) {
          const bigger = arr[i - 1];
          arr[i - 1] = arr[i];
          arr[i] = bigger;
        }
      }
      maxIndex--;
    }
    return arr;
  }

  const maxNumSort = (arr) => {
    let maxIndex = arr.length;
    while (maxIndex > 0) {
      let maxNum = arr[0];
      let maxNumIndex = 0;

      for (let i = 1; i < maxIndex; i++) {
        if (arr[i] > maxNum) {
          maxNum = arr[i];
          maxNumIndex = i;
        }
      }

      arr[maxNumIndex] = arr[maxIndex - 1];
      arr[maxIndex - 1] = maxNum;

      maxIndex--;
    }
    return arr;
  }

  const sortByInsert = (arr) => {
    let sortedPartSize = 1;

    while (sortedPartSize < arr.length) {
      let currNumber = arr[sortedPartSize];

      for (let i = sortedPartSize - 1; i > -1; i--) {
        if (arr[i] > currNumber) {
          arr[i + 1] = arr[i];
        } else {
          arr[i + 1] = currNumber;
          //mark current number as already inserted
          currNumber = null;
          break;
        }
      }
      // if we haven't found a place for current number, it's the smallest, insert at 0
      if (currNumber) {
        arr[0] = currNumber;
      }

      sortedPartSize++;
    }
    return arr;
  }

  const traverseTreeDepth = (tree) => {
    const values = [];
    let stack = [tree];

    while(stack.length) {
      const workingNode = stack.pop();
      values.push(workingNode.value);

      if (workingNode.next !== null && Array.isArray(workingNode.next)) {
        for (let i = workingNode.next.length - 1; i > -1; i--) {
          stack.push(workingNode.next[i]);
        }
      }
    }

    return values;
  }

  const traverseTreeWidth = (tree) => {
    const values = [];
    let queue = [tree];

    while(queue.length) {
      const workingNode = queue.shift();
      values.push(workingNode.value);

      if (workingNode.next !== null && Array.isArray(workingNode.next)) {
        for (const child of workingNode.next) {
          queue.push(child);
        }
      }
    }

    return values;
  }

  const checkParens = (expression) => {
    const parenArray = expression.split('');
    const stack = [];

    const openingParens = ['(', '{', '['];
    const round = ['(', ')'];
    const square = ['[', ']'];
    const curly = ['{', '}'];

    for (const paren of parenArray) {
      if (openingParens.includes(paren)) {
        stack.push(paren);
      } else {
        const lastParen = stack.pop();
        if (!(round.includes(paren) && round.includes(lastParen))
          && !(square.includes(paren) && square.includes(lastParen))
          && !(curly.includes(paren) && curly.includes(lastParen))) {
          return false;
        }
      }
    }

    return !stack.length;
  }

  const primesUnderLimit = (limit) => {
    if (limit < 2) return null;

    const primes = [2];
    for (let i = 2; i <= limit; i++) {
      let isPrime = true;

      for (const prime of primes) {
        if (i % prime === 0) {
          isPrime = false;
          break;
        }
      }

      if (isPrime) {
        primes.push(i);
      }
    }

    return primes;
  }

  const binarySearch = (arr, number) => {
    if (!arr.length || number < arr[0] || number > arr[arr.length - 1]) {
      return null;
    }

    let left = 0;
    let right = arr.length - 1;

    while (left <= right) {
      const median = (left + right) / 2;

      if (arr[Math.ceil(median)] > number) {
        right = Math.floor(median);
      } else if (arr[Math.floor(median)] < number) {
        left = Math.ceil(median);
      } else if (arr[Math.ceil(median)] === number) {
        return Math.ceil(median);
      } else if (arr[Math.floor(median)] === number) {
        return Math.floor(median);
      }
    }
  }

  console.log([1,2,5,7,8,12,17,22,34,45,78]);
  console.log(binarySearch([1,2,5,7,8,12,17,22,34,45,78], 5));
  console.log(binarySearch([1,2,5,7,8,12,17,22,34,45,78], 34));
  console.log(binarySearch([1,2,5,7,8,12,17,22,34,45,78], 1));
  console.log(binarySearch([1,2,5,7,8,12,17,22,34,45,78], 78));
</script>
</body>
</html>
